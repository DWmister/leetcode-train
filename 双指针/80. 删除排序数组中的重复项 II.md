[80. 删除排序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)

给定一个排序数组，你需要在**[原地](http://baike.baidu.com/item/原地算法)**删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**并在使用 O(1) 额外空间的条件下完成。

**示例 1:**

```
给定 nums = [1,1,1,2,2,3],

函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。

你不需要考虑数组中超出新长度后面的元素。
```

**示例 2:**

```
给定 nums = [0,0,1,1,1,1,2,3,3],

函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。

你不需要考虑数组中超出新长度后面的元素。
```

**说明:**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以**“引用”**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```js
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

**解题:**

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    let len = nums.length
    if (len < 3) {
        return len
    }

    /**
     * 方法一： 删除多余的重复项
     * 1、记录元素出现次数，默认为1；如果相邻相同则count++
     * 2、当count >= 3时，删除重复元素
     * 
     * 时间复杂度为O(N^2)，超时
     */
    // let start = 1, count = 1
    // while (start < len) {
    //     if (nums[start] === nums[start - 1]) {
    //         count ++
    //         if (count >= 3) {
    //             nums.splice(start, 1)
    //             count -= 1
    //             start -= 1
    //         }
    //     } else {
    //         console.log(1111111)
    //         count = 1
    //     }
    //     start ++
    // }

    /**
     * 方法三 循环判断删除 超时
     */
    // for(let i = 2; i < len; i++){
    //     if(nums[i - 2] === nums[i]){
    //         nums.splice(i, 1)
    //         i --
    //     }
    // }
    // return nums.length
    // let count = 1
    // for (let i = 1; i < len; i ++) {
    //     if (nums[i] === nums[i - 1]) {
    //         count ++
    //         if (count > 2) {
    //             nums.splice(i+1, 1)
    //             count --
    //             i --
    //         }
    //     } else {
    //         count = 1
    //     }
    // }
    // return nums.length


    /**
     * 方法二： 覆盖多余重复项 双指针
     * 一个指向当前遍历元素，另一个指向下一个要覆盖的元素
     * 开始第一位和第三位比较
     */
    let left = 1;
    for (let i = 2; i < len; i ++) {
        if (nums[left - 1] !== nums[i]) {
            nums[++left] = nums[i]
        }
    }
    return left + 1

};
```

